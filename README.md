# Rust Challenge

A simple application that reads a transaction log and then produces a report of the state of the accounts.

## Implementation Notes

- Using Rust's type system to enforce some of the invariants in the problem.  In particular, Dispute, Resolve and Chargeback don't use the amount field.  It can be very easy to use it anyways, so I created the AccountEvent enum to encode the variation between the different transaction types.  More could be done to simplify things in this way.  There are a few unwraps that could be removed with some light refactoring.
- Test coverage is fairly exaustive and catches most of the branches, with each branch producing a result (TransactionResult) that can be easily tested for.  More time could be spent to test potential edge cases.
- Pattern matching in Rust is super helpful, and helped me identify a few edge cases that I didn't think of in my original pseudocode.
- The problem requires strict ordering of the data, so there isn't much opportunity for parallelism.  Scaling could be handled through sharding.
- There are two global objects, accounts and transactions.  Accounts is bounded data, and I chose to pre-allocated it since it's so small (<1MB).  However, if we used u32 for account ids, that number would grow significantly and possibly not fit in the memory of an average machine.  In practice however, this object would likely be a remote database, or persisted to disk, so this really isn't a problem.  Transactions however could potentially be unbounded, and so this would likely need to be persisted to disk.  It does form part of the state of the system.  In this implementation, I modelled the transaction state (Transactions) as a HashMap.  This was convenient, though not likely how it would be implemented in practice.  How ever it's implemented, the operations on the state will need to be made atomic.  One possible was to do this is to model the Transaction state as another log.  This does introduce more complexity, but enforces ordering, and transactions are just appending to the log.   This might make sense in a very large production system.  In this way the current state of the system can be reduced to pointers to the logs, everything else is derivative.
- One factor I didn't consider initially was keeping track of the state of a dispute.  If a transaction is not in dispute, then it should be impossible to resolve or chargeback.  Enforcing this is critical to prevent abuse.  This isn't something I thought of originally, but that came up with I was writing the unit tests, and checking all of the code paths.  Thanks to Rust, these sorts of bugs quickly bubble up to the surface.
- I did some tests against mock data, but mostly I used unit tests to test the edge cases. I've included a python script that generates a very large test file that can be used for performance testing.  I didn't spend much more time on this, but it would be interesting to do more performance profiling, to see what kind of performance we can get out of Rust.  Currently with the release version, I'm processing about 2 million transactions per second on my local machine.
- One of my first ideas was to translate the floating point data from the log, and to convert it to an integer, by multiplying it by a constant factor.  For 4 decimal places, this is 10_000.  This provides us with fixed precision fractional values, and allows us to catch certain edge cases, by enforcing an unsigned integer as storage for account balances.  This ensures that the value can never go negative, and to do so would cause a panic.  All arithmetic on account balances is checked and unwrapped, to ensure panic.  I chose panic as the behavior, because this indicates a serious bug in the solution, which I would want to make known quickly.  Bugs like that can arise if we added a race condition later when parallelizing for example.  Checking for this is easy using Rust's `checked_add`, `checked_sub` integer methods.
- One nice thing about Rust is it's memory usage.  It's usually clear how you're using memory and when it's getting freed.  With garbage collected languages, you need to trust the runtime to do this for you, which doesn't always work out. It's really clear how much memory I'm using with Accounts and Transactions, and serde is a great library that can stream all of this and not require loading it all into memory.  
